<html><head><title>I Don't Know Climate</title><style>
  body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    background: #000000;
    font-family: Arial, sans-serif;
    transition: transform 0.5s ease-in-out;
    overflow-x: hidden;
  }
  canvas {
    display: block;
  }
  /* Update the NASA text styles */
  #nasaText {
    position: absolute;
    top: 20px;
    left: 0;
    right: 0;
    text-align: center;
    font-family: Arial, sans-serif;
    font-size: 32px; /* Increased from 28px */
    color: #ffffff;
    text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
    z-index: 1000;
  }

  /* Update the welcome text styles */
  #welcomeText {
    position: absolute;
    top: 50%; /* Adjust back to center */
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    font-family: Arial, sans-serif;
    z-index: 1000;
    width: 100%;
    padding: 20px;
    box-sizing: border-box;
  }

  .welcome-part {
    font-size: 28px; /* Increased from 24px */
    color: #cccccc;
    text-shadow: 0 0 10px rgba(204, 204, 204, 0.7);
  }

  .title-part {
    font-size: 42px; /* Increased from 36px */
    font-weight: bold;
    color: #ffffff;
    text-shadow: 0 0 15px rgba(255, 255, 255, 0.9);
  }

  .team-part {
    font-size: 24px; /* Increased from 20px */
    color: #999999;
    text-shadow: 0 0 8px rgba(153, 153, 153, 0.6);
  }

  #exploreButton {
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 24px;
    color: #ffffff;
    background-color: rgba(255, 255, 255, 0.2);
    border: 2px solid #ffffff;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  #exploreButton:hover {
    background-color: rgba(255, 255, 255, 0.3);
    transform: scale(1.05);
  }

  /* Add these styles for the transition effect */
  .slide-left {
    transform: translateX(-100%);
  }

  #exploreNowPage {
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 2000;
    color: white;
    box-sizing: border-box;
    transform: translateX(100%);
    transition: transform 0.5s ease-in-out;
    background: none; /* Remove the background color */
  }

  #exploreNowPage.show {
    transform: translateX(0);
  }
  
  #explorationOptions {
    display: flex;
    justify-content: space-around;
    align-items: center;
    height: 100%;
    background: rgba(0, 0, 0, 0.3); /* Reduce opacity for a brighter background */
    transition: background 0.5s ease; /* Add transition for smooth effect */
  }

  body.exploring #explorationOptions {
    background: rgba(0, 0, 0, 0.1); /* Even more transparent when exploring */
  }

  .option-box {
    background: rgba(255, 255, 255, 0.2); /* Slightly more opaque boxes */
    border: 2px solid white;
    border-radius: 10px;
    padding: 20px;
    text-align: center;
    backdrop-filter: blur(5px); /* Add a blur effect to make text more readable */
    transition: background 0.5s ease; /* Add transition for smooth effect */
  }

  body.exploring .option-box {
    background: rgba(255, 255, 255, 0.3); /* More opaque when exploring */
  }

  .option-button {
    margin-top: 10px;
    padding: 10px 20px;
    font-size: 18px;
    color: #ffffff;
    background-color: rgba(255, 255, 255, 0.2);
    border: 2px solid #ffffff;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .option-button:hover {
    background-color: rgba(255, 255, 255, 0.3);
    transform: scale(1.05);
  }

  /* Update the #exploreNowPage styles */
  .exploring #welcomeText,
  .exploring #exploreButton {
    display: none;
  }

  .sub-options {
    margin-top: 10px;
  }

  .sub-option-button {
    margin: 5px;
    padding: 8px 16px;
    font-size: 16px;
    color: #ffffff;
    background-color: rgba(255, 255, 255, 0.2);
    border: 2px solid #ffffff;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: 'Comic Sans MS', cursive, sans-serif;
  }

  .sub-option-button:hover {
    background-color: rgba(255, 255, 255, 0.3);
    transform: scale(1.05);
  }
</style></head><body>
<canvas id="pulsarCanvas"></canvas>

<div id="nasaText">NASA SPACE APPS CHALLENGE 2024</div>

<div id="welcomeText">
  <span class="welcome-part" style="font-family: 'Comic Sans MS', cursive, sans-serif;">Welcome to</span><br>
  <span class="title-part" style="font-family: 'Comic Sans MS', cursive, sans-serif;">I Don't Know Climate</span><br>
  <span class="team-part" style="font-family: 'Comic Sans MS', cursive, sans-serif;">Presented By Team: I Don't Know Climate!</span><br>
  <button id="exploreButton" style="font-family: 'Comic Sans MS', cursive, sans-serif; font-size: 18px; padding: 6px 14px; margin-top: 25px;">Explore Now</button>
</div>

<div id="exploreNowPage">
  <div id="explorationOptions">
    <div class="option-box" id="storyBox">
      <h2 style="font-family: 'Comic Sans MS', cursive, sans-serif;">Click to access Story and Data about your Region</h2>
      <a href="/F:\Nasa\home_page\Aquiz.html"><button class="option-button">Explore</button></a>
      
    </div>
    <div class="option-box" id="gameBox">
      <h2 style="font-family: 'Comic Sans MS', cursive, sans-serif;">Click here to Play Fun Games</h2>
      <button class="option-button" id="playButton">Play</button>
      <div class="sub-options" id="gameSubOptions" style="display: none;">
       <!-- <button class="sub-option-button" href="/Aquiz.html">Quiz</button>
        <button class="sub-option-button" href="/Apuzzle.html">Puzzle</button> -->
        <button class="sub-option-button" id="quizButton">Quiz</button>
        <button class="sub-option-button" id="puzzleButton">Puzzle</button>
      </div>
    </div>
  </div>
</div>

<div id="customizationMenu">
  <h2>Customize Planets</h2>
  <label for="colorMode">Color Mode:</label>
  <select id="colorMode">
    <option value="multi">Multicolored</option>
    <option value="single">Single Color</option>
  </select>
  <label for="planetColor">Planet Color:</label>
  <input type="color" id="planetColor" value="#ffffff" style="display: none;">
  <label for="planetSize">Planet Size:</label>
  <input type="range" id="planetSize" min="0.5" max="5" step="0.1" value="2.0">
  <span id="planetSizeValue">2.0</span>
  <label for="planetAmount">Planet Amount:</label>
  <input type="range" id="planetAmount" min="1" max="3800" step="1" value="42">
  <span id="planetAmountValue">42</span>
  <label for="ringProbability">Ring Probability:</label>
  <input type="range" id="ringProbability" min="0" max="1" step="0.1" value="0.5">
  <span id="ringProbabilityValue">0.5</span>
  <label for="earthProbability">Earth-like Planet Probability:</label>
  <input type="range" id="earthProbability" min="0" max="0.5" step="0.01" value="0.18">
  <span id="earthProbabilityValue">0.18</span>
  <label for="maxMoons">Max Moons per Planet:</label>
  <input type="range" id="maxMoons" min="0" max="10" step="1" value="5">
  <span id="maxMoonsValue">5</span>
</div>

<script>
const canvas = document.getElementById('pulsarCanvas');
const ctx = canvas.getContext('2d');

let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

const BACKGROUND_STARS = [];
const NUM_BACKGROUND_STARS = 200;
const planets = [];
let MAX_PLANETS = 42;
let EARTH_PROBABILITY = 0.18;
let planetSize = 2.0;
let ringProbability = 0.5;
let MAX_MOONS = 5;
const gravityWells = new Map();
const pulses = [];
const MAX_SPEED = 8;
const G = 6.67430e-11; // Gravitational constant
const SCALE_FACTOR = 1e9; // Scale factor to make gravity more noticeable
const DECELERATION_FACTOR = 0.98; // Deceleration factor
const STAR_ANIMATION_DURATION = 60; // Animation duration in frames

function noise(x, y) {
  const X = Math.floor(x) & 255;
  const Y = Math.floor(y) & 255;
  x -= Math.floor(x);
  y -= Math.floor(y);
  const u = fade(x);
  const v = fade(y);
  const A = p[X] + Y, B = p[X + 1] + Y;
  return lerp(v, lerp(u, grad(p[A], x, y), grad(p[B], x - 1, y)),
              lerp(u, grad(p[A + 1], x, y - 1), grad(p[B + 1], x - 1, y - 1)));
}

function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
function lerp(t, a, b) { return a + t * (b - a); }
function grad(hash, x, y) {
  const h = hash & 15;
  const u = h < 8 ? x : y;
  const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
  return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
}

const p = new Array(512);
for (let i = 0; i < 256; i++) p[i] = p[i + 256] = Math.floor(Math.random() * 256);

function getPlanetColor() {
  const brightness = Math.floor(Math.random() * 200) + 55; // 55-255 range for visibility
  return `rgb(${brightness}, ${brightness}, ${brightness})`;
}

function drawEarthLikePlanet(ctx, x, y, radius, seed) {
  ctx.save();
  ctx.translate(x, y);

  ctx.fillStyle = '#666666'; // Dark gray for "water"
  ctx.beginPath();
  ctx.arc(0, 0, radius, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#CCCCCC'; // Light gray for "land"
  const scale = 0.01;
  for (let px = -radius; px < radius; px++) {
    for (let py = -radius; py < radius; py++) {
      const dx = px / radius;
      const dy = py / radius;
      if (dx * dx + dy * dy <= 1) {
        const noiseVal = noise((px + seed) * scale, (py + seed) * scale);
        if (noiseVal > 0.3) {
          ctx.fillRect(px, py, 1, 1);
        }
      }
    }
  }

  ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
  ctx.lineWidth = radius * 0.1;
  ctx.beginPath();
  ctx.arc(0, 0, radius * 1.05, 0, Math.PI * 2);
  ctx.stroke();

  ctx.restore();
}

function Moon(planet) {
  this.planet = planet;
  this.radius = planet.radius * (0.1 + Math.random() * 0.2); // Moon size 10-30% of planet size
  this.distance = planet.radius * (2 + Math.random() * 3); // Distance from planet
  this.angle = Math.random() * Math.PI * 2;
  this.speed = 0.02 + Math.random() * 0.03;
  this.color = getPlanetColor();
}

Moon.prototype.update = function() {
  this.angle += this.speed;
  this.x = this.planet.x + Math.cos(this.angle) * this.distance;
  this.y = this.planet.y + Math.sin(this.angle) * this.distance;
};

Moon.prototype.draw = function() {
  ctx.fillStyle = this.color;
  ctx.beginPath();
  ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
  ctx.fill();
};

function Planet(x, y) {
  this.x = x;
  this.y = y;
  this.radius = Math.random() * 3 + 1; // Varies from 1 to 4
  this.mass = this.radius * 0.2; // Mass proportional to size
  this.vx = (Math.random() - 0.5) * 0.5;
  this.vy = (Math.random() - 0.5) * 0.5;
  this.color = getPlanetColor();
  this.hasRing = Math.random() < ringProbability;
  this.ringColor = this.hasRing ? getPlanetColor() : null;
  this.ringWidth = this.hasRing ? this.radius * 0.5 : 0;
  this.isEarthLike = (EARTH_PROBABILITY > 0 && planets.length === 0) || (Math.random() < EARTH_PROBABILITY);
  this.seed = Math.random() * 1000;
  this.moons = [];
  const moonCount = Math.floor(Math.random() * (MAX_MOONS + 1)); // 0 to MAX_MOONS
  for (let i = 0; i < moonCount; i++) {
    this.moons.push(new Moon(this));
  }
  if (this.isEarthLike) {
    this.hasRing = false;
    this.radius = Math.random() * planetSize * 1.5 + planetSize * 0.5; // Earth-like planets are slightly larger
  }
}

Planet.prototype.draw = function() {
  ctx.globalAlpha = 1;
  if (this.isEarthLike) {
    drawEarthLikePlanet(ctx, this.x, this.y, this.radius, this.seed);
  } else {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
  
    if (this.hasRing) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius + this.ringWidth, 0, Math.PI * 2);
      ctx.strokeStyle = this.ringColor;
      ctx.lineWidth = this.ringWidth * 0.3;
      ctx.stroke();
    }
  }
  
  this.moons.forEach(moon => {
    moon.update();
    moon.draw();
  });
};

Planet.prototype.update = function() {
  let totalForceX = 0;
  let totalForceY = 0;
  let isAffectedByGravity = false;

  const wellArray = Array.from(gravityWells.values());
  
  for (let i = 0; i < wellArray.length; i++) {
    const well = wellArray[i];
    const dx = well.x - this.x;
    const dy = well.y - this.y;
    const distanceSquared = dx * dx + dy * dy;
    const distance = Math.sqrt(distanceSquared);
    
    const force = (G * this.mass * well.mass) / distanceSquared * SCALE_FACTOR;
    
    totalForceX += (dx / distance) * force;
    totalForceY += (dy / distance) * force;

    const orbitalSpeed = Math.sqrt((G * well.mass) / distance) * SCALE_FACTOR;
    const tangentX = -dy / distance;
    const tangentY = dx / distance;
    
    this.vx += tangentX * orbitalSpeed * 0.01;
    this.vy += tangentY * orbitalSpeed * 0.01;

    isAffectedByGravity = true;
  }

  for (let i = 0; i < planets.length; i += 10) {
    if (this === planets[i]) continue;
    const dx = planets[i].x - this.x;
    const dy = planets[i].y - this.y;
    const distanceSquared = dx * dx + dy * dy;
    if (distanceSquared < 100) {
      const distance = Math.sqrt(distanceSquared);
      const force = (G * this.mass * planets[i].mass) / distanceSquared * SCALE_FACTOR * 0.1;
      totalForceX += (dx / distance) * force;
      totalForceY += (dy / distance) * force;
      isAffectedByGravity = true;
    }
  }

  pulses.forEach(pulse => {
    const dx = this.x - pulse.x;
    const dy = this.y - pulse.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (distance < pulse.radius) {
      const force = pulse.strength * (1 - distance / pulse.radius) / this.mass;
      totalForceX += (dx / distance) * force * 2; 
      totalForceY += (dy / distance) * force * 2; 
      isAffectedByGravity = true;
    }
  });

  const ax = totalForceX / this.mass;
  const ay = totalForceY / this.mass;
  this.vx += ax;
  this.vy += ay;

  const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
  if (speed > MAX_SPEED) {
    const ratio = MAX_SPEED / speed;
    this.vx *= ratio;
    this.vy *= ratio;
  }

  this.x += this.vx;
  this.y += this.vy;

  if (!isAffectedByGravity) {
    this.vx *= DECELERATION_FACTOR;
    this.vy *= DECELERATION_FACTOR;
  }

  const effectiveRadius = this.radius;
  if (this.x < effectiveRadius) {
    this.x = effectiveRadius;
    this.vx = Math.abs(this.vx) * 0.8;
  } else if (this.x > width - effectiveRadius) {
    this.x = width - effectiveRadius;
    this.vx = -Math.abs(this.vx) * 0.8;
  }
  
  if (this.y < effectiveRadius) {
    this.y = effectiveRadius;
    this.vy = Math.abs(this.vy) * 0.8;
  } else if (this.y > height - effectiveRadius) {
    this.y = height - effectiveRadius;
    this.vy = -Math.abs(this.vy) * 0.8;
  }
};

function createInitialPlanets() {
  planets.length = 0;
  const minDistance = 10; // Minimum distance between planet centers
  
  for (let i = 0; i < MAX_PLANETS; i++) {
    let x, y, overlapping;
    do {
      x = Math.random() * (width - 10) + 5;
      y = Math.random() * (height - 10) + 5;
      overlapping = false;
      
      for (let j = 0; j < planets.length; j++) {
        const dx = x - planets[j].x;
        const dy = y - planets[j].y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < minDistance) {
          overlapping = true;
          break;
        }
      }
    } while (overlapping);

    const planet = new Planet(x, y);
    if (!planet.isEarthLike) {
      planet.radius = Math.random() * planetSize + planetSize * 0.5; // Adjust size range
    }
    planets.push(planet);
  }
}

function generateBackgroundStars() {
  BACKGROUND_STARS.length = 0;
  for (let i = 0; i < NUM_BACKGROUND_STARS; i++) {
    BACKGROUND_STARS.push({
      x: Math.random() * width,
      y: Math.random() * height,
      radius: Math.random() * 1.5 + 0.5,
      brightness: Math.random() * 0.5 + 0.5
    });
  }
}

function animate() {
  ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
  ctx.fillRect(0, 0, width, height);
  
  BACKGROUND_STARS.forEach(star => {
    const gradient = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, star.radius);
    gradient.addColorStop(0, `rgba(255, 255, 255, ${star.brightness})`);
    gradient.addColorStop(0.1, `rgba(255, 255, 255, ${star.brightness * 0.8})`);
    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    
    ctx.beginPath();
    ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.fill();
  });
  
  planets.forEach(planet => {
    planet.update();
    planet.draw();
  });
  
  const wellArray = Array.from(gravityWells.values());
  for (let i = 0; i < wellArray.length; i++) {
    const well = wellArray[i];
    well.animationProgress = Math.min(well.animationProgress + 1, STAR_ANIMATION_DURATION);
    const animationRatio = well.animationProgress / STAR_ANIMATION_DURATION;
    
    const gradientRadius = 150 * Math.sqrt(well.mass / 1e6) * animationRatio; 
    const gradient = ctx.createRadialGradient(well.x, well.y, 0, well.x, well.y, gradientRadius);
    gradient.addColorStop(0, `rgba(255, 255, 255, ${0.8 * animationRatio})`); 
    gradient.addColorStop(0.3, `rgba(200, 200, 200, ${0.5 * animationRatio})`); 
    gradient.addColorStop(1, 'rgba(100, 100, 100, 0)');
    
    ctx.beginPath();
    ctx.arc(well.x, well.y, gradientRadius, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.fill();

    ctx.beginPath();
    ctx.arc(well.x, well.y, gradientRadius * 1.2, 0, Math.PI * 2);
    const glowGradient = ctx.createRadialGradient(well.x, well.y, gradientRadius, well.x, well.y, gradientRadius * 1.2);
    glowGradient.addColorStop(0, `rgba(200, 200, 200, ${0.3 * animationRatio})`);
    glowGradient.addColorStop(1, 'rgba(100, 100, 100, 0)');
    ctx.fillStyle = glowGradient;
    ctx.fill();

    ctx.beginPath();
    ctx.arc(well.x, well.y, 15 * Math.sqrt(well.mass / 1e6) * animationRatio, 0, Math.PI * 2); 
    ctx.fillStyle = `rgba(255, 255, 255, ${animationRatio})`; 
    ctx.fill();

    for (let j = i + 1; j < wellArray.length; j++) {
      const otherWell = wellArray[j];
      const dx = otherWell.x - well.x;
      const dy = otherWell.y - well.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance < 150) {
        ctx.beginPath();
        ctx.moveTo(well.x, well.y);
        ctx.lineTo(otherWell.x, otherWell.y);
        ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 * (1 - distance / 150)})`;
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
  }
  
  pulses.forEach((pulse, index) => {
    ctx.beginPath();
    ctx.arc(pulse.x, pulse.y, pulse.radius, 0, Math.PI * 2);
    
    const gradient = ctx.createRadialGradient(pulse.x, pulse.y, 0, pulse.x, pulse.y, pulse.radius);
    gradient.addColorStop(0, `rgba(255, 255, 255, ${1 - pulse.radius / pulse.maxRadius})`);
    gradient.addColorStop(0.8, `rgba(200, 200, 200, ${0.5 * (1 - pulse.radius / pulse.maxRadius)})`);
    gradient.addColorStop(1, 'rgba(100, 100, 100, 0)');
    
    ctx.fillStyle = gradient;
    ctx.fill();
    
    ctx.strokeStyle = `rgba(255, 255, 255, ${1 - pulse.radius / pulse.maxRadius})`;
    ctx.lineWidth = 5; 
    ctx.stroke();
    
    pulse.radius += pulse.speed;
    if (pulse.radius > pulse.maxRadius) {
      pulses.splice(index, 1);
    }
  });
  
  requestAnimationFrame(animate);
}

function handleStart(event) {
  event.preventDefault();
  const touches = event.changedTouches || [{ identifier: 'mouse', clientX: event.clientX, clientY: event.clientY }];
  for (let i = 0; i < touches.length; i++) {
    const touch = touches[i];
    gravityWells.set(touch.identifier, { 
      x: touch.clientX, 
      y: touch.clientY, 
      mass: 1e6,
      strength: 3000,
      animationProgress: 0
    });
  }
}

function handleMove(event) {
  event.preventDefault();
  const touches = event.changedTouches || [{ identifier: 'mouse', clientX: event.clientX, clientY: event.clientY }];
  for (let i = 0; i < touches.length; i++) {
    const touch = touches[i];
    if (gravityWells.has(touch.identifier)) {
      const well = gravityWells.get(touch.identifier);
      well.x = touch.clientX;
      well.y = touch.clientY;
    }
  }
}

function handleEnd(event) {
  event.preventDefault();
  const touches = event.changedTouches || [{ identifier: 'mouse' }];
  for (let i = 0; i < touches.length; i++) {
    const touch = touches[i];
    if (gravityWells.has(touch.identifier)) {
      const well = gravityWells.get(touch.identifier);
      pulses.push({
        x: well.x,
        y: well.y,
        radius: 0,
        maxRadius: Math.max(width, height), 
        speed: 15, 
        strength: 500 
      });
      gravityWells.delete(touch.identifier);
    }
  }
}

canvas.addEventListener('touchstart', handleStart, false);
canvas.addEventListener('touchmove', handleMove, false);
canvas.addEventListener('touchend', handleEnd, false);

canvas.addEventListener('mousedown', handleStart, false);
canvas.addEventListener('mousemove', (event) => {
  if (gravityWells.has('mouse')) {
    handleMove(event);
  }
}, false);
canvas.addEventListener('mouseup', handleEnd, false);

window.addEventListener('resize', () => {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
  createInitialPlanets();
  generateBackgroundStars();
});

const colorModeSelect = document.getElementById('colorMode');
const planetColorInput = document.getElementById('planetColor');
const planetSizeInput = document.getElementById('planetSize');
const planetSizeValue = document.getElementById('planetSizeValue');
const planetAmountInput = document.getElementById('planetAmount');
const planetAmountValue = document.getElementById('planetAmountValue');
const ringProbabilityInput = document.getElementById('ringProbability');
const ringProbabilityValue = document.getElementById('ringProbabilityValue');
const earthProbabilityInput = document.getElementById('earthProbability');
const earthProbabilityValue = document.getElementById('earthProbabilityValue');
const maxMoonsInput = document.getElementById('maxMoons');
const maxMoonsValue = document.getElementById('maxMoonsValue');

colorModeSelect.addEventListener('change', (event) => {
  if (event.target.value === "single") {
    planetColorInput.style.display = "block";
  } else {
    planetColorInput.style.display = "none";
  }
  createInitialPlanets();
});

planetColorInput.addEventListener('input', (event) => {
  if (colorModeSelect.value === "single") {
    createInitialPlanets();
  }
});

planetSizeInput.addEventListener('input', (event) => {
  planetSize = parseFloat(event.target.value);
  planetSizeValue.textContent = planetSize.toFixed(1);
  planets.forEach(planet => {
    if (planet.isEarthLike) {
      planet.radius = Math.random() * planetSize * 0.75 + planetSize * 0.25; // Adjust Earth-like planet size
    } else {
      planet.radius = Math.random() * planetSize + planetSize * 0.5; // Adjust normal planet size
    }
  });
});

planetAmountInput.addEventListener('input', (event) => {
  MAX_PLANETS = parseInt(event.target.value);
  planetAmountValue.textContent = MAX_PLANETS;
  createInitialPlanets();
});

ringProbabilityInput.addEventListener('input', (event) => {
  ringProbability = parseFloat(event.target.value);
  ringProbabilityValue.textContent = ringProbability.toFixed(1);
  createInitialPlanets();
});

earthProbabilityInput.addEventListener('input', (event) => {
  EARTH_PROBABILITY = parseFloat(event.target.value);
  earthProbabilityValue.textContent = EARTH_PROBABILITY.toFixed(2);
  createInitialPlanets();
});

maxMoonsInput.addEventListener('input', (event) => {
  MAX_MOONS = parseInt(event.target.value);
  maxMoonsValue.textContent = MAX_MOONS;
  createInitialPlanets();
});

// Update the smoothTransition function
function smoothTransition() {
  document.body.classList.add('exploring');
  document.getElementById('welcomeText').classList.add('slide-left');
  document.getElementById('exploreNowPage').style.display = 'block';
  setTimeout(() => {
    document.getElementById('exploreNowPage').classList.add('show');
    document.body.classList.add('brighter-background');
  }, 50);
}

// Update the "Explore Now" button event listener
document.getElementById('exploreButton').addEventListener('click', function() {
  smoothTransition();
});



// Update the event listeners for the option buttons
document.querySelectorAll('.option-button').forEach(button => {
  button.addEventListener('click', function() {
    if (this.id === 'playButton') {
      const gameSubOptions = document.getElementById('gameSubOptions');
      if (gameSubOptions.style.display === 'none') {
        gameSubOptions.style.display = 'block';
      } else {
        gameSubOptions.style.display = 'none';
      }
    } 
    // else {
    //   alert('This feature is not implemented yet.');
    // }
  });
});

// Add event listeners for the new sub-option buttons
// document.querySelectorAll('.sub-option-button').forEach(button => {
//   button.addEventListener('click', function() {
//     alert('This feature is not implemented yet.');
//   });
// });

document.getElementById('quizButton').addEventListener('click', function() {
    window.location.href = 'Aquiz.html';
  });

  document.getElementById('puzzleButton').addEventListener('click', function() {
    window.location.href = 'Apuzzle.html';
  });

createInitialPlanets();
generateBackgroundStars();
animate();
</script>
</body></html>